{"name":"Clusterflag","tagline":"Fast marker clustering for Google Maps supporting hundreds of thousands of markers","body":"ClusterFlag\r\n===========\r\n\r\nClusters LatLng points to allow a map to display different numbers of markers at different zoom levels. Built with the fast retrieval of hundreds of thousands of Google Maps markers in mind.\r\n\r\nOriginally developed for a personal project [TheyHaveYour.Info](http://theyhaveyour.info) which required a clusterer for Google Maps capable of fast browsing and aggregation of 200,000+ map markers.\r\n\r\nNo production dependencies required.\r\n\r\nEven if it takes a few seconds to actually cluster 200000 markers, once it's done you can zoom the map it doesn't need to recalculate (unlike MarkerClusterer in google-maps-utility-library-v3) - browsing the map with ClusterFlag is fast! This greedy clustering algorithm is heavily based on the wonderful [Leaflet.markercluster](https://github.com/Leaflet/Leaflet.markercluster) (MIT License).\r\n\r\n##Using ClusterFlag\r\nInclude the javascript file which will set the global variable `ClusterFlag`.\r\n*Including the script within an IIFE will make the variable non-global.*\r\n\r\nInclude your mapping library and then import the `LatLng` and `LatLngBounds` classes into ClusterFlag, e.g.\r\n\r\n`ClusterFlag.setImports(google.maps.LatLng, google.maps.LatLngBounds);`\r\n\r\nThe LatLng class must have `lat()` and `lng()` methods and constructor `LatLng(lat, lng)`.\r\nThe LatLngBounds class must have constructor `LatLngBounds(NE, SW)` and methods `getSouthWest()`, `getNorthEast()`, `contains(latlng)`, `intersects(bounds)`, `extend(latlng)` and `union(bounds)`\r\nIf you aren't using Google Maps or a mapping library, you can use the `MapLatLng` and `MapBounds` classes included in the test folder.\r\n\r\n###Creating Clusterer\r\n\r\nTo create the clusterer use `var cf = new ClusterFlag.Clusterer(maxZoom, clusterWidth)` where:\r\n\r\n* **maxZoom** - Maximum zoom level to calculate clusters for. Level 0 shows the whole world on the map.\r\nOn each subsequent zoom level the number of pixels in the world quadruples. If max zoom is too large, too many levels will be created and adding markers will be very slow. However, the `get` method shouldn't suffer.\r\n* **clusterWidth** - Smaller values causes more markers to be shown (more dense). A good starting value is 0.5.\r\n\r\n###Clustering\r\n\r\nEach marker added to the clusterer can have any properties, but must always have:\r\n\r\n* **id** - a unique ID (any type)\r\n* **latlng** - a LatLng object specifying the object's position\r\n\r\nTo add a marker `cf.add(marker)`\r\nWhen everything has been added you can call `cf.finish()` to clean up temporary arrays which are only required if adding more items and to calculate aggregate properties such as child count and centre of mass.\r\n\r\n###Getting markers\r\n\r\nOn map events such as zooming or dragging, call `cf.get(map.getBounds() : LatLngBounds, zoomLevel)` to return an array containing marker objects (the same as you added to the clusterer) and Cluster objects. **Actually displaying the results on the map is your problem** although a basic example app is included!\r\n\r\n####Cluster objects\r\n\r\nA cluster object has the following properties populated:\r\n\r\n* **id** - A unique ID\r\n* **centreOfMass** - Approximate LatLng of the centre of this cluster\r\n* **markers** - Array of marker objects which are children of this cluster (not children of children)\r\n* **childClusters** - Array of clusters which are hidden within the current cluster at this zoom level\r\n* **count** - Total number of marker objects contained within this cluster and its children (available after finish has been called)\r\n* **zoom** - Zoom level of this cluster\r\n* **bounds** - LatLngBounds\r\n* **isCluster** - true\r\n* **parent** - Cluster object which is the direct parent of this cluster.\r\nThe top level cluster (`cf.top`) has zoom = -1 and parent = null\r\n\r\n###Accumulating Aggregate Properties\r\n\r\nCalculate aggregate properties of clusters using `accumulate(acc, marker, cluster, finish)` as seen in Cluster.js.\r\nUsed in `Cluster.recalculateBounds` to calculate and attach the `bounds`, `count` and `centreOfMass` properties of clusters.\r\nExample to calculate the number of blue and green markers and to attach the result to each cluster object:\r\n\r\n```javascript\r\n\r\n    cf.accumulate(function() {\r\n        return {\r\n            blue: 0, green: 0\r\n        }\r\n    }, function(accum, marker) {\r\n        //Our markers will of course need to have a color property\r\n        if (marker.color === 'blue')\r\n            accum.blue++\r\n        else if(marker.color === 'green')\r\n            accum.green++\r\n    }, function(accum, childCluster) {\r\n        accum.blue += childCluster.blueDescendants\r\n        accum.green += childCluster.greenDescendants\r\n    }, function(self, accum) {\r\n        //Every cluster will now have the following properties\r\n        self.blueDescendants = accum.blue\r\n        self.greenDescendants = accum.green\r\n        self.overallColor = accum.blue >= accum.green ? 'blue' : 'green';\r\n    })\r\n```\r\n\r\n###License\r\n\r\nCopyright 2014 Benjamin Caller\r\n\r\nClusterFlag is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nClusterFlag is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with ClusterFlag.  If not, see [http://www.gnu.org/licenses/](http://www.gnu.org/licenses/).\r\n\r\nFor alternative licensing please contact me.\r\nAlso it'd be nice to know if you make use of this library in a project.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}