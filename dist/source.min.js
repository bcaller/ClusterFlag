//Copyright 2014 Benjamin Caller
!function (a, b) {
    function c(a, b) {
        var c = b || this;
        return function () {
            return a.apply(c, arguments)
        }
    }

    function d(a, b) {
        var c = 0, d = a.length;
        for (c; d > c; c++)b(a[c], c)
    }

    b.ClusterFlag = a;
    var e = function () {
        function a(a, b, c) {
            return a = Math.max(a, b), a = Math.min(a, c)
        }

        var b = Math.PI / 180, c = 1 / 360, d = 1 / (2 * Math.PI);
        return function (e) {
            var f = a(Math.sin(e.lat() * b), -.9999, .9999);
            return{x: .5 + e.lng() * c, y: a(.5 + .5 * Math.log((1 + f) / (1 - f)) * -d, 0, 1)}
        }
    }(), f = function () {
        var a = function (a) {
            this.cellSize = a, this.cellArea = a * a, this.grid = {}, this.objectPixelCoordinates = {}, this.maxGridX = this.pixelToGrid(1) + 1
        };
        return a.prototype = {add: function (a, b) {
            var c = this.pixelToGrid(b.x), d = this.pixelToGrid(b.y), e = this.grid[d] = this.grid[d] || {}, f = e[c] = e[c] || [];
            f.push(a), this.objectPixelCoordinates[a.id] = b
        }, remove: function (a) {
            var b = this.getObjectCoordinates(a);
            if (!b)return!1;
            var c = this.grid[this.pixelToGrid(b.y)];
            if (!c)return!1;
            var d = this.pixelToGrid(b.x), e = c[d];
            return e ? (delete this.objectPixelCoordinates[a.id], e.splice(_.indexOf(e, a), 1), e.length || delete c[d], !0) : !1
        }, pixelToGrid: function (a) {
            return Math.floor(a / this.cellSize)
        }, squareDistance: function (a, b) {
            var c = Math.abs(b.x - a.x);
            c = c > .5 ? 1 - c : c;
            var d = b.y - a.y;
            return c * c + d * d
        }, getObjectCoordinates: function (a) {
            return this.objectPixelCoordinates[a.id]
        }, getNearObject: function (a) {
            var b, c, d, e, f, g, h, i, j = this.pixelToGrid(a.x), k = this.pixelToGrid(a.y), l = this.cellArea, m = null;
            for (b = k - 1; k + 1 >= b; b++)if (e = this.grid[b])for (c = j - 1; j + 1 >= c; c++)if (f = e[(c + this.maxGridX) % this.maxGridX])for (d = 0, g = f.length; g > d; d++)h = f[d], i = this.squareDistance(this.getObjectCoordinates(h), a), l > i && (l = i, m = h);
            return m
        }}, a
    }(), g = {}, h = function (a) {
        function b(a, b) {
            a.splice(_.indexOf(a, b), 1)
        }

        var e = function (a, b) {
            this.markers = [], this.childClusters = [], this.count = 0, this.zoom = a, this.id = b
        };
        return e.prototype = function () {
            return{"Ã¸": c, isCluster: !0, addChildCluster: function (a) {
                this.childClusters.push(a), a.parent = this
            }, addMarker: function (a) {
                this.markers.push(a), a.parent = this
            }, removeMarker: function (a) {
                a.parent = null, b(this.markers, a)
            }, get: function (a, b, c, d) {
                return d || (d = []), this.zoom >= b ? void(a.contains(this.centreOfMass) && d.push(this)) : (c || [].push.apply(d, _.filter(this.markers, function (b) {
                    return a.contains(b.latlng)
                })), _(this.childClusters).each(function (e) {
                    a.intersects(e.bounds) && e.get(a, b, c, d)
                }), d)
            }, allMarkers: function (a) {
                var b = a;
                return a || (b = []), d(this.childClusters, function (a) {
                    a.allMarkers(b)
                }), [].push.apply(b, this.markers), b
            }, prune: function (a, c) {
                if (!(this.markers.length || this.childClusters.length > 1) && this.parent) {
                    b(this.parent.childClusters, this);
                    var d = this.childClusters[0];
                    this.parent.childClusters.push(d), d.parent = this.parent, c && c(this)
                }
                this.zoom < a && this.childClusters.forEach(function (b) {
                    b.prune(a, c)
                })
            }, accumulate: function (a, b, c, e) {
                var f = a ? a() : {};
                d(this.childClusters, function (d) {
                    d.accumulate(a, b, c, e), c(f, d)
                }), d(this.markers, _.partial(b, f)), e(this, f)
            }, recalculateBounds: function () {
                this.accumulate(function () {
                    return{lat: 0, lng: 0, count: 0}
                }, function (b, c) {
                    b.bounds = b.bounds ? b.bounds.extend(c.latlng) : new a.Bounds(c.latlng, c.latlng), b.lat += c.latlng.lat(), b.lng += c.latlng.lng(), b.count++
                }, function (b, c) {
                    b.bounds = b.bounds ? b.bounds.union(c.bounds) : new a.Bounds(c.bounds.getSouthWest(), c.bounds.getNorthEast()), b.lat += c.centreOfMass.lat() * c.count, b.lng += c.centreOfMass.lng() * c.count, b.count += c.count
                }, function (b, c) {
                    b.bounds = c.bounds, b.count = c.count, b.centreOfMass = new a.LatLng(c.lat / c.count, c.lng / c.count)
                })
            }}
        }(), e
    }(g);
    ClusterFlag.Clusterer = function (a, b, c, d) {
        ClusterFlag.setImports = function (b, c) {
            a.LatLng = b, a.Bounds = c
        };
        var e = function (a, b) {
            this.clusterGrids = [], this.unclusteredGrids = [], this.maxZoom = a, _.times(this.maxZoom + 1, function (a) {
                var c = b / 4 / (1 << a);
                this.clusterGrids.push(new d(c)), this.unclusteredGrids.push(new d(c))
            }.bind(this)), this.clusterId = 0, this.top = new c(-1, this.nextClusterId())
        };
        return e.prototype = {nextClusterId: function () {
            return"c" + this.clusterId++
        }, add: function (a) {
            for (var c = b(a.latlng), d = this.maxZoom; d >= 0; d--) {
                var e = this.clusterGrids[d].getNearObject(c);
                if (e)return e.addMarker(a);
                var f = this.unclusteredGrids[d].getNearObject(c);
                if (f)return this.newFriend(a, f, d);
                this.unclusteredGrids[d].add(a, c)
            }
            this.top.addMarker(a)
        }, newFriend: function (d, e, f) {
            var g = e.parent;
            g && g.removeMarker(e);
            var h = new c(f, this.nextClusterId());
            h.addMarker(e), h.addMarker(d);
            var i = b(new a.LatLng((e.latlng.lat() + d.latlng.lat()) / 2, (e.latlng.lng() + d.latlng.lng()) / 2));
            for (this.clusterGrids[f].add(h, i), k = f; k >= 0 && this.unclusteredGrids[k].remove(e); k--);
            for (var j = h, k = f - 1; k > g.zoom; k--) {
                var l = new c(k, this.nextClusterId());
                l.addChildCluster(j), this.clusterGrids[k].add(l, i), j = l
            }
            g.addChildCluster(j)
        }, get: function (a, b, c) {
            return this.top.get(a, b, c)
        }, finish: function () {
            this.top.prune(11), this.unclusteredGrids = null, this.clusterGrids = null, delete this.unclusteredGrids, delete this.clusterGrids, this.top.recalculateBounds()
        }, accumulate: function (a, b, c, d) {
            return this.top.accumulate(a, b, c, d)
        }, mutualAncestor: function (a, b) {
            for (var c = a.parent, d = b.parent, e = Math.min(c.zoom, d.zoom); e >= 0; e--) {
                for (; c.zoom > e;)c = c.parent;
                for (; d.zoom > e;)d = d.parent;
                if (c === d)return c
            }
            return this.top
        }}, e
    }(g, e, h, f)
}({}, function () {
    return this
}());
//# sourceMappingURL=source.min.map